<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>3 Августа</title>
    <style>
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
      width: 100%;
      height: 100%;
    }

    body, button, a, input, textarea, select {
      cursor: none !important;
    }

    body {
      cursor: none; /* Скрываем системный курсор */
    }

    #customCursor {
      position: fixed;
      top: 0;
      left: 0;
      width: 12px;
      height: 12px;
      background-color: white;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease, width 0.2s ease, height 0.2s ease;
    }

    /* Когда наводим на кликабельное */
    .pointer-hover #customCursor {
      width: 24px;
      height: 24px;
      background-color: white;
      opacity: 0.9;
    }

    body {
      margin: 0;
      background-color: #000;
      color: #ccc;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    #container {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      position: relative;
    }
    #startBtn {
      padding: 1rem 2rem;
      background-color: #111;
      color: #ccc;
      border: 2px solid #ccc;
      cursor: pointer;
      font-size: 1.2rem;
    }
    .slide {
      position: absolute;
      top: 100vh;
      opacity: 0;
      transition: all 0.8s ease-in-out;
      max-width: 600px;
      padding: 20px;
      text-align: center;
      text-shadow: 0 0 1px #888, 0 0 1px #aaa, 0 0 2px #ccc;
    }
    .slide.active {
      top: 50%;
      transform: translateY(-50%);
      opacity: 1;
    }
    .slide.out {
     top: -50%;
     transform: translateY(50%);
     opacity: 1;
    }
    .yellow-annot {
      color: #ffe066;
      font-weight: bold;
      border-bottom: 1px dashed #ffe066;
      position: relative;
      transition: color 0.2s;
    }
    .yellow-annot:hover {
      color: #fffbe0;
    }
    .yellow-annot-tooltip {
      display: block;
      visibility: hidden;
      opacity: 0;
      position: absolute;
      left: 50%;
      top: 2.2em;
      transform: translateX(-50%);
      background: rgba(30, 34, 40, 0.98);
      color: #ffe066;
      border-radius: 0;
      border: 1.5px solid #ffe066;
      box-shadow: 0 6px 24px 0 #000a, 0 1.5px 6px 0 #ffe06655;
      padding: 10px 18px;
      font-size: 1em;
      z-index: 2000;
      white-space: pre-line;
      min-width: 320px;
      max-width: 600px;
      pointer-events: auto;
      transition: opacity 0.18s cubic-bezier(.4,2,.6,1), visibility 0.18s cubic-bezier(.4,2,.6,1);
      font-family: 'JetBrains Mono', 'Fira Mono', 'Consolas', 'Courier New', monospace;
      font-weight: 500;
      letter-spacing: 0.02em;
      line-height: 1.5;
      text-align: left;
    }
    .yellow-annot:hover .yellow-annot-tooltip,
    .yellow-annot-tooltip:hover {
      visibility: visible;
      opacity: 1;
    }
    .yellow-animated {
      color: #ffe066;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      font-size: 1.1em;
      letter-spacing: 1px;
      margin-top: 0;
      margin-bottom: 0.5em;
      white-space: pre;
      transition: color 0.3s;
      position: fixed;
      top: 1.5em;
      left: 2em;
      text-align: left;
      z-index: 1000;
      pointer-events: none;
    }
  </style>
</head>
<div id="customCursor"></div>
<body>
  <canvas id="particleCanvas"></canvas>

  <div id="container">
    <button id="startBtn">начать</button>
  </div>
  <span id="yellowAnimatedGlobal" class="yellow-animated" style="display:none"></span>

  <audio id="ambience1" src="sound/kventa/212025__qubodup__sci-fi-laboratory-ambience.ogg" loop></audio>
  <audio id="music1" src="sound/kventa/The_Prison.mp3" loop></audio>
  <audio id="ambience3" src="sounds/ambience3.mp3" loop></audio>

  <audio id="open1" src="sound/kventa/425090__neospica__pressurized-door-opening.wav"></audio>
  <audio id="open2" src="sound/kventa/90143__pengo_au__steam_burst.wav"></audio>
  <audio id="open3" src="sound/kventa/325269__deleted_user_2104797__body-fall-2.wav"></audio>
  <audio id="open4" src="sound/kventa/195955__minian89__bucket_splash.mp3"></audio>

  <audio id="surgery" src="sound/kventa/520222__podcapocalipsis__broken-bone-and-flesh.wav"></audio>

  <audio id="access" src="sound/kventa/459992__florianreichelt__beep-short.mp3"></audio>

  <audio id="writing" src="sound/kventa/33773__digifishmusic__writing.wav"></audio>

  <audio id="click" src="sound/kventa/mixkit-old-camera-shutter-click-1137.wav"></audio>

  <script>
    
    const container = document.getElementById('container');
    const startBtn = document.getElementById('startBtn');

    const audioMap = {
      ambience1: document.getElementById('ambience1'),
      music1: document.getElementById('music1'),
      ambience2: document.getElementById('ambience2'),

      open1: document.getElementById('open1'),
      open2: document.getElementById('open2'),
      open3: document.getElementById('open3'),
      open4: document.getElementById('open4'),

      surgery: document.getElementById('surgery'),

      access: document.getElementById('access'),

      writing: document.getElementById('writing'),

      click: document.getElementById('click')
    };

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function createFilteredSource(audioElement, type = 'lowpass', freq = 500) {
  const source = audioCtx.createMediaElementSource(audioElement);
  const filter = audioCtx.createBiquadFilter();
  filter.type = type;
  filter.frequency.value = freq;
  source.connect(filter).connect(audioCtx.destination);
  return filter;
}

const filters = {
  ambience1: createFilteredSource(audioMap.ambience1),

};

    const slides = [
      {
        text: 'С днём рождения, мама.',
        play: ['music1', 'click'],
        stop: [],
      },
      {
        text: 'Я всегда буду благодарен тебе за всё, что ты для меня сделала.',
        play: ['click'],
        stop: []
      },
      {
        text: 'Ты всегда верила в меня. И когда я внезапно уехал в Москву - тоже.',
        play: ['click'],
        stop: []
      },
      {
        text: 'Я хочу, чтобы ты знала, что я тебя очень сильно люблю.',
        play: ['click'],
        stop: [],
      },
      {
        text: 'Мы прошли вместе долгий и нелёгкий путь и многое будет ждать нас впереди.',
        play: ['click'],
        stop: []
      },
      {
        text: 'Ты движешься в правильном направлении, ведь ты видишь как обретаешь счастье. Ты достаточно сильна и опытна, чтобы двигаться дальше, так что я желаю тебе удачи!<br><br><em>(Это последний слайд)</em>',
        play: ['click'],
        stop: []
      },
    ];

    let currentSlide = -1;
    let readyForClick = false;
    let yellowAnimationActive = false;

    // Вставка аннотаций: используйте {annot: "слово", info: "подсказка"} в тексте слайда
    function renderAnnotatedText(text) {
      if (!text) return '';
      // Пример: <annot word="нейроинтерфейс" info="Устройство для связи мозга с компьютером">нейроинтерфейс</annot>
      // или {annot: "нейроинтерфейс", info="Устройство для связи мозга с компьютером"}
      // Поддержка шаблона: [[аннотируемое слово|подсказка]]
      return text.replace(/\[\[([^\|\]]+)\|([^\]]+)\]\]/g, (m, word, info) => {
        return `<span class="yellow-annot">${word}<span class="yellow-annot-tooltip">${info}</span></span>`;
      });
    }

    function createSlide(slide) {
      const div = document.createElement('div');
      div.classList.add('slide');
      // Обычный текст слайда всегда отображается (если есть)
      if (slide.text) {
        const textDiv = document.createElement('div');
        textDiv.innerHTML = renderAnnotatedText(slide.text);
        div.appendChild(textDiv);
      }
      // Сохраняем yellowAnimated данные для showNextSlide (может быть массив или объект)
      if (slide.yellowAnimated) {
        div._yellowAnimated = Array.isArray(slide.yellowAnimated)
          ? slide.yellowAnimated.map(obj => ({ ...obj }))
          : [{ ...slide.yellowAnimated }];
      }
      container.appendChild(div);
      return div;
    }

    function showNextSlide() {
      if (currentSlide >= 0) {
        slidesElements[currentSlide].classList.remove('active');
        slidesElements[currentSlide].classList.add('out');
      }

      currentSlide++;

      if (currentSlide >= slides.length) return;

      const slide = slides[currentSlide];
      const { play, stop, filterOn = [], filterOff = [] } = slide;

      // Управление аудио
      stop?.forEach(id => {
        const audio = audioMap[id];
        if (audio) {
          // Останавливаем loop-аудио корректно
          audio.pause();
          try {
            audio.currentTime = 0;
            // Для loop-аудио сбрасываем loop, чтобы оно не перезапускалось автоматически
            if (audio.loop) {
              audio.loop = false;
              setTimeout(() => { audio.loop = true; }, 100);
            }
          } catch (e) {}
        }
      });

      play?.forEach(id => {
        const audio = audioMap[id];
        if (audio) {
          audio.volume = audioVolumes[id] !== undefined ? audioVolumes[id] : 0.5;
          audio.play().catch(e => console.warn("Autoplay blocked", e));
        }
      });

      filterOn?.forEach(id => {
        const filter = filters[id];
        if (filter) filter.frequency.value = 2000;
      });

      filterOff?.forEach(id => {
        const filter = filters[id];
        if (filter) filter.frequency.value = 22000;
      });

      const el = slidesElements[currentSlide];
      el.classList.add('active');
      resetParticleHomes();


      // Глобальный желтый текст
      const yellowGlobal = document.getElementById('yellowAnimatedGlobal');
      yellowGlobal.style.display = 'none';
      yellowAnimationActive = false;

      // Исправление: показывать желтый анимированный текст только если он есть в текущем слайде
      if (el._yellowAnimated && el._yellowAnimated.length > 0) {
        yellowAnimationActive = true;
        animateYellowTextSequence(el._yellowAnimated, () => {
          yellowAnimationActive = false;
        });
      } else {
        // Показывать желтый текст в слайде, если он есть как часть обычного текста (аннотации)
        yellowGlobal.style.display = 'none';
      }
    }

    // Функция для эффекта негатива с анимацией
    function triggerNegativeEffect() {
      document.body.classList.add('negative-effect-animate');
      setTimeout(() => {
        document.body.classList.remove('negative-effect-animate');
        document.body.classList.add('negative-effect');
      }, 500);
    }

    // Анимация последовательности желтых текстов
    function animateYellowTextSequence(sequence, onFinish) {
      const yellowGlobal = document.getElementById('yellowAnimatedGlobal');
      let idx = 0;
      function next() {
        if (idx >= sequence.length) {
          yellowGlobal.style.display = 'none';
          if (typeof onFinish === 'function') onFinish();
          return;
        }
        yellowGlobal.style.display = '';
        animateYellowTextGlobal(sequence[idx], () => {
          idx++;
          next();
        });
      }
      next();
    }

    // Глобальная анимация желтого текста с колбэком по завершению
    function animateYellowTextGlobal({ text, dots, final, play = [], endPlay = [] }, onFinish) {
      const yellowGlobal = document.getElementById('yellowAnimatedGlobal');
      let dotCount = 0;
      let maxDots = 3;
      let interval;
      yellowGlobal.style.display = '';
      yellowGlobal.textContent = text + (dots ? '.' : '');

      // Воспроизвести звуки при появлении желтого текста
      play.forEach(id => {
        const audio = audioMap[id];
        if (audio) {
          audio.volume = audioVolumes[id] !== undefined ? audioVolumes[id] : 0.5;
          audio.play().catch(e => {});
        }
      });

      if (dots) {
        interval = setInterval(() => {
          dotCount = (dotCount + 1) % (maxDots + 1);
          yellowGlobal.textContent = text + '.'.repeat(dotCount);
        }, 400);
      }
      setTimeout(() => {
        if (interval) clearInterval(interval);
        yellowGlobal.textContent = final;

        // Воспроизвести звуки при окончании анимации желтого текста
        endPlay.forEach(id => {
          const audio = audioMap[id];
          if (audio) {
            audio.volume = audioVolumes[id] !== undefined ? audioVolumes[id] : 0.5;
            audio.play().catch(e => {});
          }
        });

        setTimeout(() => {
          if (typeof onFinish === 'function') onFinish();
        }, 700); // небольшая пауза после финального текста
      }, 3000);
    }

    const slidesElements = slides.map(slide => createSlide(slide));

      startBtn.addEventListener('click', async () => {
      await audioCtx.resume().catch(e => console.warn("AudioContext resume error:", e));
      startBtn.style.display = 'none';
      showNextSlide();
      setTimeout(() => {
        readyForClick = true;
      }, 100);
    });

    container.addEventListener('click', () => {
      if (!readyForClick) return;
      if (yellowAnimationActive) return; // Блокируем переход, если анимация не закончилась
      if (currentSlide >= 0 && currentSlide < slides.length - 1) {
        showNextSlide();
      }
    });

    // Добавьте объект для индивидуальной громкости каждого звука
    const audioVolumes = {
      ambience1: 0.5,
      music1: 0.2,
      ambience2: 0.5,
      ambience3: 0.5,
      open1: 0.5,
      open2: 0.5,
      open3: 0.5,
      open4: 0.5,
      surgery: 1,
      access: 0.1
    };

    // Добавляем CSS для эффекта негатива и анимации
    const style = document.createElement('style');
    style.textContent = `
      body.negative-effect {
        filter: invert(1) hue-rotate(180deg) contrast(1.2) brightness(1.1);
        background: #fff !important;
        color: #000 !important;
        transition: filter 0.5s cubic-bezier(.4,2,.6,1), background 0.5s, color 0.5s;
      }
      body.negative-effect-animate {
        animation: negative-flash 0.5s cubic-bezier(.4,2,.6,1);
      }
      @keyframes negative-flash {
        0% { filter: none; background: #000; color: #ccc; }
        100% { filter: invert(1) hue-rotate(180deg) contrast(1.2) brightness(1.1); background: #fff; color: #000;}
      }
    `;
    document.head.appendChild(style);

      const cursor = document.getElementById('customCursor');

  document.addEventListener('mousemove', (e) => {
    cursor.style.left = e.clientX + 'px';
    cursor.style.top = e.clientY + 'px';
  });

  // Добавим класс, когда наводим на кликабельное
  document.addEventListener('mouseover', (e) => {
    if (e.target.closest('button, a, .clickable')) {
      document.body.classList.add('pointer-hover');
    }
  });

  document.addEventListener('mouseout', (e) => {
    if (e.target.closest('button, a, .clickable')) {
      document.body.classList.remove('pointer-hover');
    }
  });
  </script>
  <script>
  const canvas = document.getElementById("particleCanvas");
  const ctx = canvas.getContext("2d");
  let particles = [];
  const particleCount = 100;
  let mouse = { x: null, y: null };

  // --- Новые параметры для соединений ---
  const LINK_DISTANCE = 60; // расстояние для образования связи
  const LINK_BREAK_DISTANCE = 120; // максимальная длина связи
  const LINK_TIME = 1000; // мс, сколько нужно быть рядом для образования связи
  const LINK_FORCE = 0.0010; // сила притяжения по связи

  // Для хранения связей между партиклами
  let links = [];

  // Для анимации разрыва связей
  let breakingLinks = [];

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // пересоздаём home-координаты после F11
    particles.forEach(p => {
      p.homeX = Math.random() * canvas.width;
      p.homeY = Math.random() * canvas.height;
      if (p.x > canvas.width) p.x = p.homeX;
      if (p.y > canvas.height) p.y = p.homeY;
    });
  }

  resizeCanvas();

  window.addEventListener("resize", resizeCanvas);

  document.addEventListener("mousemove", e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });

  class Particle {
    constructor() {
      this.homeX = Math.random() * canvas.width;
      this.homeY = Math.random() * canvas.height;
      this.x = this.homeX;
      this.y = this.homeY;
      this.vx = (Math.random() - 0.2) * 0.2;
      this.vy = (Math.random() - 0.2) * 0.2;
      this.size = Math.random() * 2 + 1;
      this.baseAlpha = Math.random() * 0.4 + 0.4;
      this.alphaOffset = Math.random() * Math.PI * 2;
      this.wanderAngle = Math.random() * Math.PI * 2;
      this.id = Particle._id++;
      this.nearTimes = {}; // {particleId: timestamp}
    }

    update(time) {
      // Лёгкий возврат домой
      let dxHome = this.homeX - this.x;
      let dyHome = this.homeY - this.y;
      this.vx += dxHome * 0.0003;
      this.vy += dyHome * 0.0003;

      // Случайное блуждание
      this.wanderAngle += (Math.random() - 0.5) * 0.05;
      this.vx += Math.cos(this.wanderAngle) * 0.02;
      this.vy += Math.sin(this.wanderAngle) * 0.02;

      // Отталкивание от мыши
      let dx = this.x - mouse.x;
      let dy = this.y - mouse.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 100) {
        this.vx += dx / dist * 0.08;
        this.vy += dy / dist * 0.08;
      }

      // Притяжение к соединённым партиклам
      for (const link of links) {
        let other = null;
        if (link.a === this) other = link.b;
        else if (link.b === this) other = link.a;
        if (other) {
          let dxl = other.x - this.x;
          let dyl = other.y - this.y;
          let d = Math.sqrt(dxl * dxl + dyl * dyl) || 1;
          // Слабое притяжение
          this.vx += dxl / d * LINK_FORCE;
          this.vy += dyl / d * LINK_FORCE;
        }
      }

      // Движение
      this.x += this.vx;
      this.y += this.vy;

      // friction
      this.vx *= 0.94;
      this.vy *= 0.94;

      // мерцание
      this.alpha = this.baseAlpha + Math.sin(time / 1000 + this.alphaOffset) * 0.2;
    }

    getOpacity() {
      let opacity = this.alpha;

      const slides = document.querySelectorAll('.slide.active, .slide.out');
      slides.forEach(slide => {
        const rect = slide.getBoundingClientRect();
        const cx = this.x;
        const cy = this.y;

        const dx = Math.max(rect.left - cx, 0, cx - rect.right);
        const dy = Math.max(rect.top - cy, 0, cy - rect.bottom);
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < 120) {
          let fade = distance / 120;
          opacity *= fade;
        }
      });

      return Math.max(0, Math.min(1, opacity));
    }

    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${this.getOpacity()})`;
      ctx.fill();
    }
  }
  Particle._id = 0;

  for (let i = 0; i < particleCount; i++) {
    particles.push(new Particle());
  }

  // --- Логика для образования и разрыва связей ---
  function updateLinks(time) {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const a = particles[i], b = particles[j];
        const dx = a.x - b.x, dy = a.y - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Проверяем, есть ли уже связь
        let link = links.find(l => (l.a === a && l.b === b) || (l.a === b && l.b === a));

        if (dist < LINK_DISTANCE) {
          // Если рядом, увеличиваем таймер близости
          if (!a.nearTimes[b.id]) a.nearTimes[b.id] = time;
          if (!b.nearTimes[a.id]) b.nearTimes[a.id] = time;
          const nearTime = Math.max(a.nearTimes[b.id], b.nearTimes[a.id]);
          if (!link && time - nearTime > LINK_TIME) {
            // Создаём связь с progress=0 (будет анимироваться до 1)
            links.push({ a, b, created: time, progress: 0 });
          }
        } else {
          // Не рядом — сбрасываем таймер
          a.nearTimes[b.id] = time;
          b.nearTimes[a.id] = time;
        }

        // Если связь есть, но партиклы далеко — разрываем (анимируем разрыв)
        if (link && dist > LINK_BREAK_DISTANCE) {
          // Удаляем из links, добавляем в breakingLinks с progress
          links = links.filter(l => l !== link);
          breakingLinks.push({ ...link, breaking: true });
        }
      }
    }
    // Удаляем связи, если один из партиклов исчез (на resize)
    links = links.filter(l => particles.includes(l.a) && particles.includes(l.b));
    breakingLinks = breakingLinks.filter(l => particles.includes(l.a) && particles.includes(l.b));
  }

  function drawLinks() {
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.1;

    // Анимируем появление связей
    for (const link of links) {
      // Анимация progress (0..1)
      if (link.progress < 1) link.progress += 0.08;
      if (link.progress > 1) link.progress = 1;

      const { a, b, progress } = link;
      // Линия тянется от a к b по progress
      const x1 = a.x, y1 = a.y;
      const x2 = a.x + (b.x - a.x) * progress;
      const y2 = a.y + (b.y - a.y) * progress;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // Анимируем разрыв связей
    for (let i = breakingLinks.length - 1; i >= 0; i--) {
      const link = breakingLinks[i];
      link.progress -= 0.08;
      if (link.progress <= 0) {
        breakingLinks.splice(i, 1);
        continue;
      }
      const { a, b, progress } = link;
      // Линия сжимается обратно к a
      const x1 = a.x, y1 = a.y;
      const x2 = a.x + (b.x - a.x) * progress;
      const y2 = a.y + (b.y - a.y) * progress;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    ctx.restore();
  }

  function animateParticles(time = 0) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updateLinks(time);

    drawLinks();

    for (let p of particles) {
      p.update(time);
      p.draw();
    }
    requestAnimationFrame(animateParticles);
  }

  animateParticles();

  function resetParticleHomes() {
    particles.forEach(p => {
      p.homeX = Math.random() * canvas.width;
      p.homeY = Math.random() * canvas.height;
    });
    // Сброс связей при смене home
    links = [];
    breakingLinks = [];
    particles.forEach(p => p.nearTimes = {});
  }

  </script>


</body>
</html>

